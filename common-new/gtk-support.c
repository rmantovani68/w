/*
 * DO NOT EDIT THIS FILE - it is generated by Glade.
 */

#ifdef HAVE_CONFIG_H
#  include <config.h>
#endif

#include <sys/types.h>
#include <sys/stat.h>
#include <time.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>

#include <gtk/gtk.h>

#include <trace.h>
#include <gtk-support.h>

/* This is an internally used function to check if a pixmap file exists. */
static gchar *check_file_exists(const gchar *directory, const gchar *filename);

/* This is an internally used function to create pixmaps. */
static GtkWidget* create_dummy_pixmap(GtkWidget       *widget, gboolean         gnome_pixmap);

/* 
* rm 05-05-2003 : modificata per problemi di funzionamento
*/
GtkWidget *lookup_widget(GtkWidget *widget, const gchar *widget_name)
{
  GtkWidget *parent, *found_widget=NULL;

	if(widget==(GtkWidget *)NULL){
		return (GtkWidget *)0;
	}

  for (;;) {
		/* lo cerco nel widget */
		if((found_widget = (GtkWidget*) gtk_object_get_data (GTK_OBJECT (widget), widget_name)))
			break;

		if (GTK_IS_MENU (widget))
			parent = gtk_menu_get_attach_widget (GTK_MENU (widget));
		else
			parent = widget->parent;
		if (parent == NULL)
			break;
		widget = parent;
	}

  return found_widget;
}

/* This is a dummy pixmap we use when a pixmap can't be found. */
static char *dummy_pixmap_xpm[] = {
/* columns rows colors chars-per-pixel */
"1 1 1 1",
"  c None",
/* pixels */
" "
};

GList *pixmaps_directories = NULL;

/* Use this function to set the directory containing installed pixmaps. */
void add_pixmap_directory (const gchar *directory)
{
  pixmaps_directories = g_list_prepend (pixmaps_directories, g_strdup (directory));
}

#ifdef OLD_VERSION

GdkPixmap *create_dummy_pixmap(GtkWidget *widget,GdkPixmap *gdkpixmap, GdkBitmap *mask)
{
  GdkColormap *colormap;

  colormap = gtk_widget_get_colormap (widget);
  gdkpixmap = gdk_pixmap_colormap_create_from_xpm_d (NULL, colormap, &mask, NULL, dummy_pixmap_xpm);
  if (gdkpixmap == NULL)
    g_error ("Couldn't create replacement pixmap.");
  return gdkpixmap;
}
/* This is an internally used function to create pixmaps. */
GtkWidget *create_pixmap(GtkWidget *widget, const gchar *filename)
{
  gchar *found_filename = NULL;
  GdkColormap *colormap;
  GdkPixmap *gdkpixmap;
  GdkBitmap *mask;
  GtkWidget *pixmap;
  GList *elem;

  /* We first try any pixmaps directories set by the application. */
  elem = pixmaps_directories;
  while (elem)
    {
      found_filename = check_file_exists ((gchar*)elem->data, filename);
      if (found_filename)
        break;
      elem = elem->next;
    }

  /* If we haven't found the pixmap, try the source directory. */
  if (!found_filename)
    {
      found_filename = check_file_exists ("../pixmaps", filename);
    }

  if (!found_filename)
    {
      g_warning ("Couldn't find pixmap file: %s", filename);
      return create_dummy_pixmap_widget (widget);
    }

  colormap = gtk_widget_get_colormap (widget);
  gdkpixmap = gdk_pixmap_colormap_create_from_xpm (NULL, colormap, &mask,
                                                   NULL, found_filename);
  if (gdkpixmap == NULL)
    {
      g_warning ("Error loading pixmap file: %s", found_filename);
      g_free (found_filename);
      return create_dummy_pixmap_widget (widget);
    }
  g_free (found_filename);
  pixmap = gtk_pixmap_new (gdkpixmap, mask);
  gdk_pixmap_unref (gdkpixmap);
  gdk_bitmap_unref (mask);
  return pixmap;
}

/* 
* This is an internally used function to create pixmaps. 
*/
int set_pixmap(GtkWidget *widget, const gchar *filename)
{
  gchar *found_filename = NULL;
  GdkColormap *colormap;
  GdkPixmap *gdkpixmap;
  GdkBitmap *mask;
  GList *elem;
	int bRetValue=1;

  /* We first try any pixmaps directories set by the application. */
  elem = pixmaps_directories;
  while (elem) {
		found_filename = check_file_exists ((gchar*)elem->data, filename);
		if (found_filename) break;
		elem = elem->next;
	}

  /* If we haven't found the pixmap, try the source directory. */
  if (!found_filename) {
		found_filename = check_file_exists ("../pixmaps", filename);
	}

  if (!found_filename) {
		g_warning ("Couldn't find pixmap file: %s", filename);
		gdkpixmap=create_dummy_pixmap (widget, gdkpixmap, mask);
		bRetValue=0;
	}

  colormap = gtk_widget_get_colormap (widget);
  gdkpixmap = gdk_pixmap_colormap_create_from_xpm (NULL, colormap, &mask, NULL, found_filename);
  if (gdkpixmap == NULL) {
		g_warning ("Error loading pixmap file: %s", found_filename);
		g_free (found_filename);
		gdkpixmap=create_dummy_pixmap (widget, gdkpixmap, mask);
		bRetValue=0;
	}
  g_free (found_filename);
  gtk_pixmap_set(GTK_PIXMAP(widget),gdkpixmap, mask);
  gdk_pixmap_unref (gdkpixmap);
  gdk_bitmap_unref (mask);
	return bRetValue;
}
#endif

/* This is an internally used function to create pixmaps. */
static GtkWidget* create_dummy_pixmap(GtkWidget       *widget, gboolean         gnome_pixmap)
{
  GdkColormap *colormap;
  GdkPixmap *gdkpixmap;
  GdkBitmap *mask;
  GtkWidget *pixmap;

  if (gnome_pixmap)
    {
      return gnome_pixmap_new_from_xpm_d (dummy_pixmap_xpm);
    }

  colormap = gtk_widget_get_colormap (widget);
  gdkpixmap = gdk_pixmap_colormap_create_from_xpm_d (NULL, colormap, &mask,
                                                     NULL, dummy_pixmap_xpm);
  if (gdkpixmap == NULL)
    g_error ("Couldn't create replacement pixmap.");
  pixmap = gtk_pixmap_new (gdkpixmap, mask);
  gdk_pixmap_unref (gdkpixmap);
  gdk_bitmap_unref (mask);
  return pixmap;
}

/* This is an internally used function to create pixmaps. */
GtkWidget* create_pixmap(GtkWidget       *widget, const gchar     *filename, gboolean         gnome_pixmap)
{
  GtkWidget *pixmap;
  GdkColormap *colormap;
  GdkPixmap *gdkpixmap;
  GdkBitmap *mask;
  gchar *found_filename = NULL;
  gchar *pathname;
  gchar *ptr;
  GList *elem;

  if (!filename || !filename[0]){
		return create_dummy_pixmap (widget, gnome_pixmap);
	}
	
	if((ptr=rindex(filename,'/'))){
		filename=(ptr+1);
	}

  /* We first try any pixmaps directories set by the application. */
  elem = pixmaps_directories;
  while (elem) {
		found_filename = check_file_exists ((gchar*)elem->data, filename);
		if (found_filename) break;
		elem = elem->next;
	}

  /* If we haven't found the pixmap, try the source directory. */
  if (!found_filename) {
		found_filename = check_file_exists ("../pixmaps", filename);
	}

  if (!found_filename) {
		return create_dummy_pixmap (widget, gnome_pixmap);
	}


/*
  pathname = gnome_pixmap_file (found_filename);
  if (!pathname)
    {
      g_warning ("Couldn't find pixmap file: %s", found_filename);
      return create_dummy_pixmap (widget, gnome_pixmap);
    }

  if (gnome_pixmap)
    {
      pixmap = gnome_pixmap_new_from_file (pathname);
      g_free (pathname);
      return pixmap;
    }
	*/

	pathname=found_filename;

  colormap = gtk_widget_get_colormap (widget);
  gdkpixmap = gdk_pixmap_colormap_create_from_xpm (NULL, colormap, &mask,
                                                   NULL, pathname);
  if (gdkpixmap == NULL)
    {
      g_warning ("Couldn't create pixmap from file: %s", pathname);
      g_free (pathname);
      return create_dummy_pixmap (widget, gnome_pixmap);
    }
  g_free (pathname);

  pixmap = gtk_pixmap_new (gdkpixmap, mask);
  gdk_pixmap_unref (gdkpixmap);
  gdk_bitmap_unref (mask);
  return pixmap;
}

/* This is an internally used function to create imlib images. */
GdkImlibImage* create_image (const gchar     *filename)
{
  GdkImlibImage *image;
  gchar *pathname;

  pathname = gnome_pixmap_file (filename);
  if (!pathname)
    {
      g_warning ("Couldn't find pixmap file: %s", filename);
      return NULL;
    }

  image = gdk_imlib_load_image (pathname);
  g_free (pathname);
  return image;
}

int set_pixmap(GtkWidget *widget, const gchar *filename)
{
  gchar *found_filename = NULL;
  GdkColormap *colormap;
  GdkPixmap *gdkpixmap;
  GdkBitmap *mask;
  GList *elem;
	int bRetValue=1;

  /* We first try any pixmaps directories set by the application. */
  elem = pixmaps_directories;
  while (elem) {
		found_filename = check_file_exists ((gchar*)elem->data, filename);
		if (found_filename) break;
		elem = elem->next;
	}

  /* If we haven't found the pixmap, try the source directory. */
  if (!found_filename) {
		found_filename = check_file_exists ("../pixmaps", filename);
	}

  if (!found_filename) {
		g_warning ("Couldn't find pixmap file: %s", filename);
		gdkpixmap=(GdkPixmap *)create_dummy_pixmap (widget, 0);
		bRetValue=0;
	}

  colormap = gtk_widget_get_colormap (widget);
  gdkpixmap = gdk_pixmap_colormap_create_from_xpm (NULL, colormap, &mask, NULL, found_filename);
  if (gdkpixmap == NULL) {
		g_warning ("Error loading pixmap file: %s", found_filename);
		g_free (found_filename);
		gdkpixmap=(GdkPixmap *)create_dummy_pixmap (widget, 0);
		bRetValue=0;
	}
  g_free (found_filename);
  gtk_pixmap_set(GTK_PIXMAP(widget),gdkpixmap, mask);
  gdk_pixmap_unref (gdkpixmap);
  gdk_bitmap_unref (mask);
	return bRetValue;
}


/* This is an internally used function to check if a pixmap file exists. */
gchar* check_file_exists (const gchar *directory, const gchar *filename)
{
  gchar *full_filename;
  struct stat s;
  gint status;

  full_filename = (gchar*) g_malloc (strlen (directory) + 1
                                     + strlen (filename) + 1);
  strcpy (full_filename, directory);
  strcat (full_filename, G_DIR_SEPARATOR_S);
  strcat (full_filename, filename);

  status = stat (full_filename, &s);
  if (status == 0 && S_ISREG (s.st_mode))
    return full_filename;

  g_free (full_filename);
  return NULL;
}


int gtk_clist_get_first_selected_row(GtkCList *lst)
{
	GList *glist;

	glist=g_list_first(GTK_CLIST(lst)->selection);

	if(glist==NULL){
		/*
		* nessuna riga della lista e' selezionata
		*/
		return -1;
	} else {
		return GPOINTER_TO_INT(glist->data);
	}
}

/*
* funzione di stampa formattata in un gtk label widget
*/
void gtk_label_printf(GtkWidget *w,char *fmt,...)
{
	va_list args;
	char msgbuf[1024];

	va_start(args,fmt);
	(void)vsprintf(msgbuf,fmt,args);
	va_end(args);
	gtk_label_set (GTK_LABEL(w), msgbuf);
}

/*
* funzione di stampa formattata in un gtk text widget
*/
void gtk_text_printf(GdkColor *Color,GtkWidget *w,char *fmt,...)
{
	va_list args;
	char msgbuf[1024];

	va_start(args,fmt);
	(void)vsprintf(msgbuf,fmt,args);
	va_end(args);
	gtk_text_insert (GTK_TEXT(w), NULL, Color, NULL, msgbuf, -1);
}

/*
* gtk_text_read_file(w,szFileName)
* legge il file szfilename e lo inserisce nella gtk_text specificata in input
*/
void gtk_text_read_file(GtkWidget *w,char *szFileName)
{
	int fd, num_bytes;
	char *buf;
	struct stat file_status;

	if ((fd = open(szFileName, O_RDONLY)) <= 0)
		return;
	else {
		if (fstat(fd, &file_status) == -1)
			return;
		if ((buf = malloc(file_status.st_size)) == (char *)NULL)
			return;
		if ((num_bytes = read(fd, buf, file_status.st_size)) <= 0)
			return;
	}
	buf[file_status.st_size]='\0';
	close(fd);
	gtk_text_insert (GTK_TEXT(w), NULL, NULL, NULL, buf, -1);
	free(buf);
}


/*
* void gtk_update(void)
*/
void gtk_update(void)
{
  while (gtk_events_pending())
    gtk_main_iteration();
}

void gtk_widget_set_foreground(GtkWidget *w,GdkColor *Color)
{
	GtkStyle *style;

	if(w==(GtkWidget *)NULL){
		return;
	}
	/* set foreground and text to color */
	style = gtk_style_copy(gtk_widget_get_style(w));
	gtk_style_ref(style);
	style->text[GTK_STATE_NORMAL] = *Color;
	style->fg[GTK_STATE_NORMAL] = *Color;
	gtk_widget_set_style(w, style);
	gtk_style_unref(style);
}

void gtk_widget_set_background(GtkWidget *w,GdkColor *Color)
{
	GtkStyle *style;

	if(w==(GtkWidget *)NULL){
		return;
	}

	/* set background to color */
	style = gtk_style_copy(gtk_widget_get_style(w));
	gtk_style_ref(style);
	style->bg[GTK_STATE_NORMAL] = *Color;
	gtk_widget_set_style(w, style);
	gtk_style_unref(style);
}


void trace_debug(GdkColor *Color,gboolean bDate,gboolean bNewLine,GtkWidget *txt,char *fmt,...)
{
  va_list args;
  char szMessage[1024];
	char tbuf[80];
	char dbuf[80];

  va_start(args,fmt);
  (void)vsprintf(szMessage,fmt,args);
  va_end(args);
#ifdef TRACE
	if(bNewLine){
		trace_out_vstr_date(1,szMessage);
	} else {
		trace_out_vstr(0,szMessage);
	}
#endif
	if(txt){
		strcat(szMessage,"\n");
		gtk_text_printf(Color,txt,"[%s] [%s] : ", trace_getdate(time((long *)0), dbuf), trace_gettime_msec(time((long *)0), tbuf));
		gtk_text_printf(Color,txt,szMessage);
	}
}

void SetCfgWidgets(GtkWidget *dlg,PCFGITEM pItems)
{
	int nIndex=0;
	char szTmp[256];
	int nTmp;
	GtkWidget *w;


	while(pItems[nIndex].pszItemName){
		switch(pItems[nIndex].ItemType){
			case CFG_TYPE_BOOL:
				switch(pItems[nIndex].WidgetType){
					case CFG_TOGGLE_BUTTON_WIDGET:
						if((w=get_widget(dlg,pItems[nIndex].pszWidgetName))){
							gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(w),*(pItems[nIndex].ItemValue.pbBool));
						}
					break;
					case CFG_SPIN_BUTTON_WIDGET:
						if((w=get_widget(dlg,pItems[nIndex].pszWidgetName))){
							gtk_spin_button_set_value(GTK_SPIN_BUTTON(w),*(pItems[nIndex].ItemValue.pbBool));
						}
					break;
					case CFG_ENTRY_WIDGET:
						if((w=get_widget(dlg,pItems[nIndex].pszWidgetName))){
							sprintf(szTmp,"%d", *(pItems[nIndex].ItemValue.pbBool));
							gtk_entry_set_text(GTK_ENTRY(w),szTmp);
						}
					break;
					case CFG_NO_WIDGET:
						/* eliminate compiler warning */
					break;
				}
			break;
			case CFG_TYPE_INT:
				switch(pItems[nIndex].WidgetType){
					case CFG_TOGGLE_BUTTON_WIDGET:
						if((w=get_widget(dlg,pItems[nIndex].pszWidgetName))){
							gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(w),*(pItems[nIndex].ItemValue.pnInt));
						}
					break;
					case CFG_SPIN_BUTTON_WIDGET:
						if((w=get_widget(dlg,pItems[nIndex].pszWidgetName))){
							gtk_spin_button_set_value(GTK_SPIN_BUTTON(w),*(pItems[nIndex].ItemValue.pnInt));
						}
					break;
					case CFG_ENTRY_WIDGET:
						if((w=get_widget(dlg,pItems[nIndex].pszWidgetName))){
							sprintf(szTmp,"%d", *(pItems[nIndex].ItemValue.pnInt));
							gtk_entry_set_text(GTK_ENTRY(w),szTmp);
						}
					break;
					case CFG_NO_WIDGET:
						/* eliminate compiler warning */
					break;
				}
			break;
			case CFG_TYPE_STRING:
				switch(pItems[nIndex].WidgetType){
					case CFG_TOGGLE_BUTTON_WIDGET:
						if((w=get_widget(dlg,pItems[nIndex].pszWidgetName))){
							nTmp=atoi(pItems[nIndex].ItemValue.pszString);
							gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(w),nTmp);
						}
					break;
					case CFG_SPIN_BUTTON_WIDGET:
						if((w=get_widget(dlg,pItems[nIndex].pszWidgetName))){
							nTmp=atoi(pItems[nIndex].ItemValue.pszString);
							gtk_spin_button_set_value(GTK_SPIN_BUTTON(w),nTmp);
						}
					break;
					case CFG_ENTRY_WIDGET:
						if((w=get_widget(dlg,pItems[nIndex].pszWidgetName))){
							gtk_entry_set_text(GTK_ENTRY(w),pItems[nIndex].ItemValue.pszString);
						}
					break;
					case CFG_NO_WIDGET:
						/* eliminate compiler warning */
					break;
				}
			break;
			case CFG_TYPE_NONE:
				/* eliminate compiler warning */
			break;
		}
		nIndex++;
	}
}

void ApplyCfgItems(GtkWidget *dlg,PCFGITEM pItems)
{
	int nIndex=0;
	char szTmp[256];
	GtkWidget *w;


	while(pItems[nIndex].pszItemName){
		switch(pItems[nIndex].ItemType){
			case CFG_TYPE_BOOL:
				switch(pItems[nIndex].WidgetType){
					case CFG_TOGGLE_BUTTON_WIDGET:
						if((w=get_widget(dlg,pItems[nIndex].pszWidgetName))){
							*(pItems[nIndex].ItemValue.pbBool) = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(w));
						}
					break;
					case CFG_SPIN_BUTTON_WIDGET:
						if((w=get_widget(dlg,pItems[nIndex].pszWidgetName))){
							*(pItems[nIndex].ItemValue.pbBool) = gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(w));
						}
					break;
					case CFG_ENTRY_WIDGET:
						if((w=get_widget(dlg,pItems[nIndex].pszWidgetName))){
							strcpy(szTmp,gtk_entry_get_text(GTK_ENTRY(w)));
							*(pItems[nIndex].ItemValue.pbBool) = atoi(szTmp);
						}
					break;
					case CFG_NO_WIDGET:
						/* eliminate compiler warning */
					break;
				}
			break;
			case CFG_TYPE_INT:
				switch(pItems[nIndex].WidgetType){
					case CFG_TOGGLE_BUTTON_WIDGET:
						if((w=get_widget(dlg,pItems[nIndex].pszWidgetName))){
							*(pItems[nIndex].ItemValue.pnInt) = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(w));
						}
					break;
					case CFG_SPIN_BUTTON_WIDGET:
						if((w=get_widget(dlg,pItems[nIndex].pszWidgetName))){
							*(pItems[nIndex].ItemValue.pnInt) = gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(w));
						}
					break;
					case CFG_ENTRY_WIDGET:
						if((w=get_widget(dlg,pItems[nIndex].pszWidgetName))){
							strcpy(szTmp,gtk_entry_get_text(GTK_ENTRY(w)));
							*(pItems[nIndex].ItemValue.pnInt) = atoi(szTmp);
						}
					break;
					case CFG_NO_WIDGET:
						/* eliminate compiler warning */
					break;
				}
			break;
			case CFG_TYPE_STRING:
				switch(pItems[nIndex].WidgetType){
					case CFG_TOGGLE_BUTTON_WIDGET:
						if((w=get_widget(dlg,pItems[nIndex].pszWidgetName))){
							sprintf(pItems[nIndex].ItemValue.pszString,"%d",gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(w)));
						}
					break;
					case CFG_SPIN_BUTTON_WIDGET:
						if((w=get_widget(dlg,pItems[nIndex].pszWidgetName))){
							sprintf(pItems[nIndex].ItemValue.pszString,"%d",gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(w)));
						}
					break;
					case CFG_ENTRY_WIDGET:
						if((w=get_widget(dlg,pItems[nIndex].pszWidgetName))){
							strcpy(pItems[nIndex].ItemValue.pszString,gtk_entry_get_text(GTK_ENTRY(w)));
						}
					break;
					case CFG_NO_WIDGET:
						/* eliminate compiler warning */
					break;
				}
			break;
			case CFG_TYPE_NONE:
				/* eliminate compiler warning */
			break;
		}
		nIndex++;
	}
}

